use std::collections::HashMap;
use std::mem::take;
use std::path::{Path, PathBuf};

use lalrpop_util::ParseError;

use crate::parser;
use crate::runfile::*;
use crate::doubled;
use crate::out::{RunscriptError, Location};

grammar(id: &[usize], self_path: &Path);

extern {
    type Error = RunscriptError;
}

match {
    r"![^\n]*\n" => {}, // Defined comments as "!..." so whitespace is lexed by the default lexer
    r"[ \t]+" => {},   // Then need to ignore spaces and tabs
	r"b(?:!|r)?|r!?" => BFLAGS,
	"$include",
} else {
    r"\n+" => "\n",
    r"[[:alnum:]%*-/:<-@\[\]-_{}~]+" => CLARG,
    _
}

pub RunFile: RunFile = {
    <Targets> "\n"*
}

Targets: RunFile = {
	<mut t:Targets> "\n"* "$include" <l:@L> <p:ClargOrAlnum> <r:@R> =>? {
		let file_str = {
			let mut file_str = p.clone();
			file_str.push_str(".run");
			file_str
		};
		let self_dir = self_path.parent().expect("File should have parent");
		let file_path = self_dir.join(file_str);
		let (source, path): (Box<str>, PathBuf) = match std::fs::read_to_string(&file_path) {
			Ok(s) => (s.into_boxed_str().into(), file_path),
			Err(file_err) => {
				let dir_path = {
					let mut dir_path = self_dir.join(&p);
					dir_path.push("run");
					dir_path
				};
				match std::fs::read_to_string(&dir_path) {
					Ok(s) => (s.into_boxed_str().into(), dir_path),
					Err(dir_err) => return Err(ParseError::User { error: RunscriptError::InvalidInclude {
						include_str: p,
						file_err,
						dir_err,
						location: Location::new(id.into(), l, r),
					}}),
				}
			}
		};
		let new_id = {
			let mut new = id.to_vec();
			new.push(t.includes.len());
			new
		};
		let file = parser::RunFileParser::new().parse(&new_id, &path, unsafe { &*(&*source as *const str) })?;
		t.includes.push(RunFileRef {
			file: Some(file),
			name: p,
			line_ends: source.char_indices().filter_map(|(i, c)| if c == '\n' { Some(i) } else { None }).collect(),
			source,
		});
		Ok(t)
	},
    <mut t:Targets> "\n"* <l:@L> "##" <m:TargetMeta> <r:@R> "\n" <c:Lines> "#/"  =>? {
        let mut n = match take(&mut t.global_target) {
            Some(t) => t,
            None => Target::default()
        };
        if let Some(t) = n.commands.get(&m) {
            return Err(ParseError::User { error: RunscriptError::MultipleDefinition {
                target: "#".to_owned(),
                location: Location::new(id.into(), l, r),
                previous_def: t.loc.clone(),
            }});
        }
        n.commands.insert(m, TargetInfo { commands: c, loc: Location::new(id.into(), l, r) });
        t.global_target = Some(n);
        Ok(t)
    },
    <mut t:Targets> "\n"* <l:@L> "#-" <m:TargetMeta> <r:@R> "\n" <c:Lines> "#/" =>? {
        let mut n = match take(&mut t.default_target) {
            Some(t) => t,
            None => Target::default()
        };
        if let Some(t) = n.commands.get(&m) {
            return Err(ParseError::User { error: RunscriptError::MultipleDefinition {
                target: "-".to_owned(),
                location: Location::new(id.into(), l, r),
                previous_def: t.loc.clone(),
            }});
        }
        n.commands.insert(m, TargetInfo { commands: c, loc: Location::new(id.into(), l, r) });
        t.default_target = Some(n);
        Ok(t)
    },
    <mut t:Targets> "\n"* <l:@L> "#" <s:ClargOrAlnum> <m:TargetMeta> <r:@R> "\n" <c:Lines> "#/" =>? {
        let target_name = s;
        let mut n = match t.targets.remove(&target_name) {
            Some(t) => t,
            None => Target::default()
        };
        if let Some(t) = n.commands.get(&m) {
            return Err(ParseError::User { error: RunscriptError::MultipleDefinition {
                target: target_name,
                location: Location::new(id.into(), l, r),
                previous_def: t.loc.clone(),
            }});
        }
        n.commands.insert(m, TargetInfo { commands: c, loc: Location::new(id.into(), l, r) });
        t.targets.insert(target_name, n);
        Ok(t)
    },
    => RunFile {
        global_target: None,
        default_target: None,
		targets: HashMap::new(),
		includes: vec![],
    }
}

TargetMeta: TargetMeta = {
    BFLAGS => TargetMeta {
        script: match <> {
            "b!" => ScriptType::BuildOnly,
            "b"  => ScriptType::Build,
            "br" => ScriptType::BuildAndRun,
            "r"  => ScriptType::Run,
            "r!" => ScriptType::RunOnly,
            _ => unreachable!()
        }
    },
    => TargetMeta { script: ScriptType::BuildAndRun },
}

Lines: Vec<Command> = {
    <mut x:Lines> <c:Line> "\n" => {
        x.push(c);
        x
    },
    <x:Lines> "\n" => x,
    <Line> "\n" => vec![<>],
    "\n" => vec![],
}

pub Line: Command = {
    <Command>,
    <c:Line> "&&" <mut n:Command> => {
        *n.chained = ChainedCommand::And(c);
        n
    },
    <c:Line> "||" <mut n:Command> => {
        *n.chained = ChainedCommand::Or(c);
        n
    },
    <c:Line> "|" <mut n:Command> => {
        *n.chained = ChainedCommand::Pipe(c);
        n
    },
}

Command: Command = {
    <l:@L> <t:ClargOrAlnum> <r:@R> <a:Arg*> => Command {
        target: t,
        args: a,
        chained: Box::new(ChainedCommand::None),
        loc: Location::new(id.into(), l, r),
    }
}

//TODO: Location tracking properly
Arg: Argument = {
    <l:@L> <c:ClargOrAlnum> <r:@R> => Argument::Unquoted(ArgPart::Str(c), Location::new(id.into(), l, r)),
    r#""[[:alnum:] !#$%&'(-/:-@\[\]-`{-~]*""# =>? Ok(Argument::Double(doubled::DoubledArgParser::new().parse(id, self_path, <>)?)),
    r#"'[[:alnum:] "!#$%&(-/:-@\[\]-`{-~]*'"# => Argument::Single(<>[1..<>.len() - 1].to_owned()),
    r"\$[[:digit:]]+" => Argument::Unquoted(ArgPart::Arg(<>[1..].parse::<usize>().expect("Expected regex to only match digits")), Location::new(id.into(), 0, 0)),
    "$" <CLARG> => Argument::Unquoted(ArgPart::Var(<>.to_owned()), Location::new(id.into(), 0, 0)),
    "$" "(" <Command> ")" => Argument::Unquoted(ArgPart::Cmd(<>), Location::new(id.into(), 0, 0)),
}

ClargOrAlnum: String = {
	<CLARG> => <>.to_owned(),
}

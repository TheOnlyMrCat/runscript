use std::collections::HashMap;

use crate::runfile::*;
use crate::lexer::*;

grammar;

extern {
    type Location = usize;
    type Error = LexErr;

    enum Tok {
        "\n" => Tok::Newline,
        "#"  => Tok::Hash,
        "##" => Tok::DoubleHash,
        "#/" => Tok::HashSlash,
        "#-" => Tok::HashDash,
        ARGV => Tok::CommandPart(_),
        NAME => Tok::TargetName(_),
    }
}

pub RunFile: RunFile = {
    Targets
}

Targets: RunFile = {
    "##" "\n" <c:Commands> "#/" <mut t:Targets> => {
        if let Some(_) = t.global_target {
            panic!("Multiple definitions of global target");
        }
        t.global_target = Some(Target {
            commands: c,
        });
        t
    },
    "#-" "\n" <c:Commands> "#/" <mut t:Targets> => {
        if let Some(_) = t.default_target {
            panic!("Multiple definitions of default target");
        }
        t.default_target = Some(Target {
            commands: c,
        });
        t
    },
    "#" <n:NAME> "\n" <c:Commands> "#/" <mut t:Targets> => {
        t.targets.insert(n.target_name(), Target {
            commands: c,
        });
        t
    },
    => RunFile {
        global_target: None,
        default_target: None,
        targets: HashMap::new(),
    }
}

//TODO
TargetMeta: () = {

}

Commands: Vec<Command> = {
    <mut x:Commands> <c:Command> "\n" => {
        x.push(c);
        x
    },
    <Command> "\n" => vec![<>]
}

//TODO: Figure out what exactly sh accepts as a command
Command: Command = {
    <t:ARGV> <a:Args> => Command {
        target: t.command_part(),
        args: a,
    }
}

//TODO: Figure out what exactly sh accepts in arguments
Args: Vec<Argument> = {
    <r:Arg> => vec![r],
    <mut a:Args> <r:Arg> => {
        a.push(r);
        a
    }
}

Arg: Argument = {
    <t:ARGV> => vec![ArgPart::Str(t.command_part())]
}
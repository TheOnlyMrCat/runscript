use std::collections::HashMap;
use std::mem::take;

use crate::runfile::*;

grammar;

match {
    r"![^\n]*\n" => {}, // Defined comments as "!..." so whitespace is lexed by the default lexer
    r"b(?:!|r)?|r!?" => BFLAGS,
    r"[ \t]+" => " ",
} else {
    r"\s+" => "\n",
    r"[/\-:\w]+" => CLARG,
    _
}

pub RunFile: RunFile = {
    Targets
}

Targets: RunFile = {
    "##" " "? <m:TargetMeta> "\n" <c:Commands> "#/" "\n"* <mut t:Targets> => {
        let mut n = match take(&mut t.global_target) {
            Some(t) => t,
            None => Target::default()
        };
        if let Some(_) = n.commands.get(&m) {
            panic!("Multiple definitions of global target");
        }
        n.commands.insert(m, c);
        t.global_target = Some(n);
        t
    },
    "#-" " "? <m:TargetMeta> "\n" <c:Commands> "#/" "\n"* <mut t:Targets> => {
        let mut n = match take(&mut t.default_target) {
            Some(t) => t,
            None => Target::default()
        };
        if let Some(_) = n.commands.get(&m) {
            panic!("Multiple definitions of default target");
        }
        n.commands.insert(m, c);
        t.default_target = Some(n);
        t
    },
    "#" <s:CLARG> " "? <m:TargetMeta> "\n" <c:Commands> "#/" "\n"* <mut t:Targets> => {
        let target_name = s.to_owned();
        let mut n = match t.targets.remove(&target_name) {
            Some(t) => t,
            None => Target::default()
        };
        if let Some(_) = n.commands.get(&m) {
            panic!("Multiple definitions of target {}", target_name);
        }
        n.commands.insert(m, c);
        t.targets.insert(target_name, n);
        t
    },
    => RunFile {
        global_target: None,
        default_target: None,
        targets: HashMap::new(),
    }
}

TargetMeta: TargetMeta = {
    BFLAGS => TargetMeta {
        script: match <> {
            "b!" => ScriptType::BuildOnly,
            "b"  => ScriptType::Build,
            "br" => ScriptType::BuildAndRun,
            "r"  => ScriptType::Run,
            "r!" => ScriptType::RunOnly,
            _ => unreachable!()
        }
    },
    => TargetMeta { script: ScriptType::BuildAndRun },
}

Commands: Vec<Command> = {
    <mut x:Commands> <c:Command> "\n" => {
        x.push(c);
        x
    },
    <x:Commands> "\n" => x,
    <Command> "\n" => vec![<>],
    "\n" => vec![],
}

Command: Command = {
    <t:CLARG> <a:(" " <Args>)?> => Command {
        target: t.to_owned(),
        args: match a { Some(a) => a, None => vec![] },
    }
}

Args: Vec<Argument> = {
    <mut a:(<Arg> " ")*> <l:Arg> => {
        a.push(l);
        a
    }
}

Arg: Argument = {
    <DoubleQuotedArg> => Argument { parts: <> },
    <QuotedArg> => Argument { parts: vec![ArgPart::Str(<>.to_owned())] },
    CLARG => Argument { parts: vec![ArgPart::Str(<>.to_owned())] },
    "$" <CLARG> => Argument { parts: vec![ArgPart::Var(<>.to_owned())] },
    "$" "(" <Command> ")" => Argument { parts: vec![ArgPart::Cmd(<>)] },
}

QuotedArg: String = {
    "'" <a:(<CLARG> " ")*> <l:CLARG> "'" => a.iter().fold("".to_owned(), |acc, x| acc + x + " ") + l
}

DoubleQuotedArg: Vec<ArgPart> = {
    "\"" <a:DoubleQuotedPart*> "\"" => a.iter().fold(Vec::<ArgPart>::new(), |acc, x| {
        let mut acc = acc;
        match acc.last_mut() {
            Some(e) => {
                match e {
                    ArgPart::Str(s) => {
                        match x {
                            ArgPart::Str(t) => s.push_str(&t),
                            _ => acc.push(x.clone()),
                        }
                    }
                    _ => acc.push(x.clone()),
                }
            },
            None => acc.push(x.clone()),
        }
        acc
    })
}

DoubleQuotedPart: ArgPart = {
    " " => ArgPart::Str(<>.to_owned()),
    CLARG => ArgPart::Str(<>.to_owned()),
    "$" <CLARG> => ArgPart::Var(<>.to_owned()),
    "$" "(" <Command> ")" => ArgPart::Cmd(<>),
}
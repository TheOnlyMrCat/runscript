use std::collections::HashMap;
use std::mem::take;

use crate::runfile::*;
use crate::lexer::*;

grammar;

extern {
    type Location = usize;
    type Error = LexErr;

    enum Tok {
        "\n" => Tok::Newline,
        "#"  => Tok::Hash,
        "##" => Tok::DoubleHash,
        "#/" => Tok::HashSlash,
        "#-" => Tok::HashDash,
        "'"  => Tok::SingleQuote,
        "\"" => Tok::DoubleQuote,
        "("  => Tok::OpenParen,
        ")"  => Tok::CloseParen,
        "$"  => Tok::Dollar,
        " "  => Tok::Whitespace,
        ARGV => Tok::CommandPart(_),
        NAME => Tok::TargetName(_),
        SCTP => Tok::MetaScript(_),
    }
}

pub RunFile: RunFile = {
    Targets
}

Targets: RunFile = {
    "##" <m:TargetMeta> "\n" <c:Commands> "#/" <mut t:Targets> => {
        let mut n = match take(&mut t.global_target) {
            Some(t) => t,
            None => Target::default()
        };
        if let Some(_) = n.commands.get(&m) {
            panic!("Multiple definitions of global target");
        }
        n.commands.insert(m, c);
        t.global_target = Some(n);
        t
    },
    "#-" <m:TargetMeta> "\n" <c:Commands> "#/" <mut t:Targets> => {
        let mut n = match take(&mut t.default_target) {
            Some(t) => t,
            None => Target::default()
        };
        if let Some(_) = n.commands.get(&m) {
            panic!("Multiple definitions of default target");
        }
        n.commands.insert(m, c);
        t.default_target = Some(n);
        t
    },
    "#" <s:NAME> <m:TargetMeta> "\n" <c:Commands> "#/" <mut t:Targets> => {
        let target_name = s.target_name();
        let mut n = match t.targets.remove(&target_name) {
            Some(t) => t,
            None => Target::default()
        };
        if let Some(_) = n.commands.get(&m) {
            panic!("Multiple definitions of target {}", target_name);
        }
        n.commands.insert(m, c);
        t.targets.insert(target_name, n);
        t
    },
    => RunFile {
        global_target: None,
        default_target: None,
        targets: HashMap::new(),
    }
}

TargetMeta: TargetMeta = {
    SCTP => TargetMeta { script: <>.meta_script() },
    => TargetMeta { script: ScriptType::BuildAndRun },
}

Commands: Vec<Command> = {
    <mut x:Commands> <c:Command> "\n" => {
        x.push(c);
        x
    },
    <x:Commands> "\n" => x,
    <Command> "\n" => vec![<>],
    "\n" => vec![],
}

//TODO: Figure out what exactly sh accepts as a command
Command: Command = {
    <t:ARGV> <a:Args> => Command {
        target: t.command_part(),
        args: a,
    }
}

//TODO: Figure out what exactly sh accepts in arguments
Args: Vec<Argument> = {
    <r:Arg> => vec![r],
    <mut a:Args> " " <r:Arg> => {
        a.push(r);
        a
    }
}

Arg: Argument = {
    "\"" <mut d:DoubleQuotedArg> "\"" => Argument { parts: { d.reverse() d } },
    "'" <QuotedArg> "'" => Argument { parts: vec![ArgPart::Str(<>)] },
    ARGV => Argument { parts: vec![ArgPart::Str(<>.command_part())] },
    "$" <ARGV> => Argument { parts: vec![ArgPart::Var(<>.command_part())] }
}

QuotedArg: String = {
    <q:QuotedArg> " " <v:ARGV> => q + " " + &v.command_part(),
    ARGV => <>.command_part(),
}

DoubleQuotedArg: Vec<ArgPart> = {
    <q:QuotedArg> " " <v:DollarEscape> " " <mut d:DoubleQuotedArg> => {
        d.push(ArgPart::Str(q + " "));
        d.push(s);
        d.push(ArgPart::Str(" ".to_owned()));
        d
    },
    <q:QuotedArg> " " <s:DollarEscape> <mut d:DoubleQuotedArg> => {
        d.push(ArgPart::Str(q + " "));
        d.push(s);
        d
    },
    <q:QuotedArg> <s:DollarEscape> " " <mut d:DoubleQuotedArg> => {
        d.push(ArgPart::Str(q));
        d.push(s);
        d.push(ArgPart::Str(" ".to_owned()));
        d
    },
    <q:QuotedArg> <s:DollarEscape> <mut d:DoubleQuotedArg> => {
        d.push(q);
        d.push(s);
        d
    },
    <s:DollarEscape> " " <mut d:DoubleQuotedArg> => {
        d.push(s);
        d.push(ArgPart::Str(" ".to_owned()));
        d
    },
    <s:DollarEscape> <mut d:DoubleQuotedArg> => {
        d.push(s);
        d
    },
    <q:QuotedArg> => vec![ArgPart::Str(q)],
    <s:DollarEscape> => vec![s],
    => vec![]
}

DollarEscape: ArgPart = {
    "$" <ARGV> => ArgPart::Var(v.command_part()),
    "$" "(" <Command> ")" => ArgPart::Cmd(<>),
}